{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nvar _jsxFileName = \"/Users/carsonbrown/git/react-query/examples/optimistic-updates-typescript/pages/index.tsx\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as React from 'react';\nimport axios from 'axios';\nimport { useQuery, useQueryClient, useMutation, QueryClient, QueryClientProvider } from 'react-query';\nimport { ReactQueryDevtools } from 'react-query/devtools';\nvar client = new QueryClient();\n\nfunction fetchTodos() {\n  var res;\n  return _regeneratorRuntime.async(function fetchTodos$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(axios.get('/api/data'));\n\n        case 2:\n          res = _context.sent;\n          return _context.abrupt(\"return\", res.data);\n\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, _Promise);\n}\n\nfunction useTodos(options) {\n  return useQuery('todos', fetchTodos, options);\n}\n\nfunction TodoCounter() {\n  var _counterQuery$data;\n\n  // subscribe only to changes in the 'data' prop, which will be the\n  // amount of todos because of the select function\n  var counterQuery = useTodos({\n    select: function select(data) {\n      return data.items.length;\n    },\n    notifyOnChangeProps: ['data']\n  });\n  React.useEffect(function () {\n    console.log('rendering counter');\n  });\n  return __jsx(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 47,\n      columnNumber: 10\n    }\n  }, \"TodoCounter: \", (_counterQuery$data = counterQuery.data) !== null && _counterQuery$data !== void 0 ? _counterQuery$data : 0);\n}\n\nfunction Example() {\n  var _this = this,\n      _queryInfo$error;\n\n  var queryClient = useQueryClient();\n\n  var _React$useState = React.useState(''),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      text = _React$useState2[0],\n      setText = _React$useState2[1];\n\n  var _useTodos = useTodos(),\n      isFetching = _useTodos.isFetching,\n      queryInfo = _objectWithoutProperties(_useTodos, [\"isFetching\"]);\n\n  var addTodoMutation = useMutation(function (newTodo) {\n    return axios.post('/api/data', {\n      text: newTodo\n    });\n  }, {\n    // When mutate is called:\n    onMutate: function onMutate(newTodo) {\n      var previousTodos;\n      return _regeneratorRuntime.async(function onMutate$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              setText(''); // Cancel any outgoing refetches (so they don't overwrite our optimistic update)\n\n              _context2.next = 3;\n              return _regeneratorRuntime.awrap(queryClient.cancelQueries('todos'));\n\n            case 3:\n              // Snapshot the previous value\n              previousTodos = queryClient.getQueryData('todos'); // Optimistically update to the new value\n\n              if (previousTodos) {\n                queryClient.setQueryData('todos', _objectSpread({}, previousTodos, {\n                  items: [].concat(_toConsumableArray(previousTodos.items), [{\n                    id: Math.random().toString(),\n                    text: newTodo\n                  }])\n                }));\n              }\n\n              return _context2.abrupt(\"return\", {\n                previousTodos: previousTodos\n              });\n\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, _Promise);\n    },\n    // If the mutation fails, use the context returned from onMutate to roll back\n    onError: function onError(err, variables, context) {\n      if (context === null || context === void 0 ? void 0 : context.previousTodos) {\n        queryClient.setQueryData('todos', context.previousTodos);\n      }\n    },\n    // Always refetch after error or success:\n    onSettled: function onSettled() {\n      queryClient.invalidateQueries('todos');\n    }\n  });\n  return __jsx(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 94,\n      columnNumber: 5\n    }\n  }, __jsx(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 7\n    }\n  }, \"In this example, new items can be created using a mutation. The new item will be optimistically added to the list in hopes that the server accepts the item. If it does, the list is refetched with the true items from the list. Every now and then, the mutation may fail though. When that happens, the previous list of items is restored and the list is again refetched from the server.\"), __jsx(\"form\", {\n    onSubmit: function onSubmit(e) {\n      e.preventDefault();\n      addTodoMutation.mutate(text);\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 103,\n      columnNumber: 7\n    }\n  }, __jsx(\"input\", {\n    type: \"text\",\n    onChange: function onChange(event) {\n      return setText(event.target.value);\n    },\n    value: text,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 9\n    }\n  }), __jsx(\"button\", {\n    disabled: addTodoMutation.isLoading,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 114,\n      columnNumber: 9\n    }\n  }, \"Create\")), __jsx(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 7\n    }\n  }), queryInfo.isSuccess && __jsx(React.Fragment, null, __jsx(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 11\n    }\n  }, \"Updated At: \", new Date(queryInfo.data.ts).toLocaleTimeString()), __jsx(\"ul\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 123,\n      columnNumber: 11\n    }\n  }, queryInfo.data.items.map(function (todo) {\n    return __jsx(\"li\", {\n      key: todo.id,\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 125,\n        columnNumber: 15\n      }\n    }, todo.text);\n  })), isFetching && __jsx(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 128,\n      columnNumber: 26\n    }\n  }, \"Updating in background...\")), queryInfo.isLoading && 'Loading', (_queryInfo$error = queryInfo.error) === null || _queryInfo$error === void 0 ? void 0 : _queryInfo$error.message);\n}\n\nexport default function App() {\n  return __jsx(QueryClientProvider, {\n    client: client,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 5\n    }\n  }, __jsx(Example, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 7\n    }\n  }), __jsx(TodoCounter, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 141,\n      columnNumber: 7\n    }\n  }), __jsx(ReactQueryDevtools, {\n    initialIsOpen: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 142,\n      columnNumber: 7\n    }\n  }));\n}","map":{"version":3,"sources":["/Users/carsonbrown/git/react-query/examples/optimistic-updates-typescript/pages/index.tsx"],"names":["React","axios","useQuery","useQueryClient","useMutation","QueryClient","QueryClientProvider","ReactQueryDevtools","client","fetchTodos","get","res","data","useTodos","options","TodoCounter","counterQuery","select","items","length","notifyOnChangeProps","useEffect","console","log","Example","queryClient","useState","text","setText","isFetching","queryInfo","addTodoMutation","newTodo","post","onMutate","cancelQueries","previousTodos","getQueryData","setQueryData","id","Math","random","toString","onError","err","variables","context","onSettled","invalidateQueries","e","preventDefault","mutate","event","target","value","isLoading","isSuccess","Date","ts","toLocaleTimeString","map","todo","error","message","App"],"mappings":"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","sourcesContent":["import * as React from 'react'\nimport axios, { AxiosError } from 'axios'\n\nimport {\n  useQuery,\n  useQueryClient,\n  useMutation,\n  QueryClient,\n  QueryClientProvider,\n  UseQueryOptions,\n} from 'react-query'\nimport { ReactQueryDevtools } from 'react-query/devtools'\n\nconst client = new QueryClient()\n\ntype Todos = {\n  items: readonly {\n    id: string\n    text: string\n  }[]\n  ts: number\n}\n\nasync function fetchTodos(): Promise<Todos> {\n  const res = await axios.get('/api/data')\n  return res.data\n}\n\nfunction useTodos<TData = Todos>(\n  options?: UseQueryOptions<Todos, AxiosError, TData>\n) {\n  return useQuery('todos', fetchTodos, options)\n}\n\nfunction TodoCounter() {\n  // subscribe only to changes in the 'data' prop, which will be the\n  // amount of todos because of the select function\n  const counterQuery = useTodos({\n    select: data => data.items.length,\n    notifyOnChangeProps: ['data'],\n  })\n\n  React.useEffect(() => {\n    console.log('rendering counter')\n  })\n\n  return <div>TodoCounter: {counterQuery.data ?? 0}</div>\n}\n\nfunction Example() {\n  const queryClient = useQueryClient()\n  const [text, setText] = React.useState('')\n  const { isFetching, ...queryInfo } = useTodos()\n\n  const addTodoMutation = useMutation(\n    newTodo => axios.post('/api/data', { text: newTodo }),\n    {\n      // When mutate is called:\n      onMutate: async (newTodo: string) => {\n        setText('')\n        // Cancel any outgoing refetches (so they don't overwrite our optimistic update)\n        await queryClient.cancelQueries('todos')\n\n        // Snapshot the previous value\n        const previousTodos = queryClient.getQueryData<Todos>('todos')\n\n        // Optimistically update to the new value\n        if (previousTodos) {\n          queryClient.setQueryData<Todos>('todos', {\n            ...previousTodos,\n            items: [\n              ...previousTodos.items,\n              { id: Math.random().toString(), text: newTodo },\n            ],\n          })\n        }\n\n        return { previousTodos }\n      },\n      // If the mutation fails, use the context returned from onMutate to roll back\n      onError: (err, variables, context) => {\n        if (context?.previousTodos) {\n          queryClient.setQueryData<Todos>('todos', context.previousTodos)\n        }\n      },\n      // Always refetch after error or success:\n      onSettled: () => {\n        queryClient.invalidateQueries('todos')\n      },\n    }\n  )\n\n  return (\n    <div>\n      <p>\n        In this example, new items can be created using a mutation. The new item\n        will be optimistically added to the list in hopes that the server\n        accepts the item. If it does, the list is refetched with the true items\n        from the list. Every now and then, the mutation may fail though. When\n        that happens, the previous list of items is restored and the list is\n        again refetched from the server.\n      </p>\n      <form\n        onSubmit={e => {\n          e.preventDefault()\n          addTodoMutation.mutate(text)\n        }}\n      >\n        <input\n          type=\"text\"\n          onChange={event => setText(event.target.value)}\n          value={text}\n        />\n        <button disabled={addTodoMutation.isLoading}>Create</button>\n      </form>\n      <br />\n      {queryInfo.isSuccess && (\n        <>\n          <div>\n            {/* The type of queryInfo.data will be narrowed because we check for isSuccess first */}\n            Updated At: {new Date(queryInfo.data.ts).toLocaleTimeString()}\n          </div>\n          <ul>\n            {queryInfo.data.items.map(todo => (\n              <li key={todo.id}>{todo.text}</li>\n            ))}\n          </ul>\n          {isFetching && <div>Updating in background...</div>}\n        </>\n      )}\n      {queryInfo.isLoading && 'Loading'}\n      {queryInfo.error?.message}\n    </div>\n  )\n}\n\nexport default function App() {\n  return (\n    <QueryClientProvider client={client}>\n      <Example />\n      <TodoCounter />\n      <ReactQueryDevtools initialIsOpen />\n    </QueryClientProvider>\n  )\n}\n"]},"metadata":{},"sourceType":"module"}